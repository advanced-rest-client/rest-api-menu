<!--
@license
Copyright 2018 The Advanced REST client authors <arc@mulesoft.com>
Licensed under the Apache License, Version 2.0 (the "License"); you may not
use this file except in compliance with the License. You may obtain a copy of
the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
License for the specific language governing permissions and limitations under
the License.
-->
<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../dom-reorderer/dom-reorderer.html">
<link rel="import" href="../paper-toast/paper-toast.html">
<link rel="import" href="../paper-item/paper-item.html">
<link rel="import" href="../paper-progress/paper-progress.html">
<dom-module id="rest-api-menu">
  <template>
    <style>
    :host {
      display: block;
      background-color: var(--rest-api-menu-background-color, inherit);
      position: relative;
      overflow: auto;
      @apply --layout-flex;
      @apply --layout-vertical;
      @apply --rest-api-menu;
    }

    paper-item {
      @apply --arc-font-menu;
      font-weight: 400;
      min-height: 40px;
      cursor: pointer;
      @apply --layout-center;
      @apply --rest-api-menu-list-item;
    }

    paper-item.dragging {
      z-index: 1;
      background-color: #fff;
    }

    paper-item.iron-selected {
      background-color: var(--rest-api-menu-selected-item-background-color, rgba(255, 152, 0, 0.24));
    }

    .name {
      @apply --layout-flex;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
      font-size: 14px;
      @apply --rest-api-menu-name-label;
    }

    paper-progress {
      width: calc(100% - 32px);
      margin: 0 16px;
      position: absolute;
    }

    .empty-info {
      @apply --arc-font-body1;
      font-style: italic;
      margin: 1em 16px;
      color: var(--arc-menu-empty-info-color);
    }

    .empty-title {
      @apply --paper-font-title;
      white-space: normal;
      color: var(--arc-menu-empty-info-title-color);
    }

    .empty-message {
      @apply --layout-flex;
      @apply --layout-vertical;
      @apply --layout-center-center;
      text-align: center;
    }

    [hidden] {
      display: none !important;
    }
    </style>
    <paper-progress hidden$="[[!querying]]" indeterminate></paper-progress>
    <template is="dom-if" if="[[dataUnavailable]]">
      <div class="empty-message">
        <h3 class="empty-title">Drop API project here</h3>
        <p class="empty-info">There is no API stored with the application</p>
      </div>
    </template>
    <dom-reorderer on-dom-order-changed="_onReorder">
      <template is="dom-repeat" items="[[items]]" id="list">
        <paper-item on-tap="_openAPI" title$="[[item.title]]" class$="[[_computeItemClass(item._id, selectedApi)]]">
          <span class="name">[[item.title]], [[item.version]]</span>
        </paper-item>
      </template>
    </dom-reorderer>
    <paper-toast id="reorderError" class="error-toast" text="Unable to reorder items. Please, report an issue."></paper-toast>
  </template>
  <script>
  /**
   * A quick access menu for REST API projects
   *
   * A list of REST APIs in the ARC main menu.
   * The element uses direct implementation of the PouchDB to make a query to the
   * datastore.
   * It also listens to `datastore-destroyed` custom event update state of the list
   * items when datastore was destroyed.
   *
   * It listens for `selected-rest-api-changed` custom event as an alternative
   * to setting `selectedApi` property directly on the element.
   *
   * ### Example
   *
   * ```html
   * <rest-api-menu selected-api="[[route.api]]"></rest-api-menu>
   * ```
   *
   * ### Datastore access
   *
   * This element uses events API to access datastore data. This is provided by the
   * `arc-models/rest-api-model` element. See documentation for this element if you
   * need to implement own data exchange logic.
   *
   * Datastore element is not in the shadow DOM of this element and is should be
   * included in the application DOM.
   *
   * ```html
   * <link rel="import" href="bower_components/arc-models/rest-api-model.html">
   * <link rel="import" href="bower_components/rest-api-menu/rest-api-menu.html">
   * <rest-api-menu selected-api="[[route.api]]"></rest-api-menu>
   * <rest-api-model></rest-api-model>
   * ```
   *
   * ### StylingEEEEEE
   * `<rest-api-menu>` provides the following custom properties and mixins for styling:
   *
   * Custom property | Description | Default
   * ----------------|-------------|----------
   * `--rest-api-menu` | Mixin applied to the element | `{}`
   * `--rest-api-menu-background-color` | Background color of the menu | `inherit`
   * `--rest-api-menu-list-item` | Mixin applied to each list item | `{}`
   * `--rest-api-menu-selected-item-background-color` | Background color of the selected list item | `rgba(255, 152, 0, 0.24)`
   * `--rest-api-menu-name-label` | Mixin applied to the name label | `{}`
   * `--arc-menu-empty-info-color` | Color applied to the empty info section | ``
   * `--arc-menu-empty-info-title-color` | Color applied to the title in the empty info section | ``
   *
   * @polymer
   * @customElement
   * @memberof UiElements
   * @demo demo/index.html
   */
  class RestApiMenu extends Polymer.Element {
    static get is() {return 'rest-api-menu';}
    static get properties() {
      return {
        /**
         * Saved items restored from the datastore.
         */
        items: Array,
        // True when the element is querying the database for the data.
        querying: {
          type: Boolean,
          readOnly: true,
          notify: true
        },
        // Computed value, true if the `items` property has values.
        hasItems: {
          type: Boolean,
          value: false,
          computed: '_computeHasItems(items.length)',
          notify: true
        },
        /**
         * Computed value. True if query ended and there's no results.
         */
        dataUnavailable: {
          type: Boolean,
          computed: '_computeDataUnavailable(hasItems, querying)'
        },
        // Currently selected project ID
        selectedApi: String,
        // Page token for datastore pagination
        nextPageToken: String
      };
    }

    constructor() {
      super();
      this._onDatabaseDestroy = this._onDatabaseDestroy.bind(this);
      this._selecteApiHandler = this._selecteApiHandler.bind(this);
      this._indexUpdated = this._indexUpdated.bind(this);
      this._indexDeleted = this._indexDeleted.bind(this);
    }

    connectedCallback() {
      super.connectedCallback();
      window.addEventListener('datastore-destroyed', this._onDatabaseDestroy);
      window.addEventListener('selected-rest-api-changed', this._selecteApiHandler);
      window.addEventListener('rest-api-index-updated', this._indexUpdated);
      window.addEventListener('rest-api-deleted', this._indexDeleted);
      if (!this.querying && !this.items) {
        this.makeQuery();
      }
    }

    disconnectedCallback() {
      super.disconnectedCallback();
      window.removeEventListener('datastore-destroyed', this._onDatabaseDestroy);
      window.removeEventListener('selected-rest-api-changed', this._selecteApiHandler);
      window.removeEventListener('rest-api-index-updated', this._indexUpdated);
      window.removeEventListener('rest-api-deleted', this._indexDeleted);
    }
    /**
     * Resets the state of the variables.
     */
    reset() {
      if (this.nextPageToken) {
        this.nextPageToken = undefined;
      }
      this._setQuerying(false);
      this.set('items', []);
    }
    /**
     * Refreshes the data from the datastore.
     * It resets the query options, clears items and makes a query to the datastore.
     */
    refresh() {
      this.reset();
      this.makeQuery();
    }
    // Handler for the `datastore-destroyed` custom event
    _onDatabaseDestroy(e) {
      let datastore = e.detail.datastore;
      if (!datastore || !datastore.length) {
        return;
      }
      if (typeof datastore === 'string') {
        datastore = [datastore];
      }
      if (datastore.indexOf('rest-api-index') === -1 && datastore[0] !== 'all') {
        return;
      }
      this.refresh();
    }
    /**
     * Computes class name for the HTML element representing a saved item.
     */
    _computeItemClass(_id, selectedProject) {
      if (_id && _id === selectedProject) {
        return 'iron-selected';
      }
    }
    // Computes value for the `hasItems` property.
    _computeHasItems(length) {
      return !!(length);
    }
    /**
     * The function to call when new query for data is needed.
     */
    makeQuery() {
      if (this.__makingQuery) {
        return;
      }
      this.__makingQuery = true;
      setTimeout(() => {
        this.__makingQuery = false;
        this._loadPage();
      }, 20);
    }
    /**
     * Performs the query and processes the result.
     */
    _loadPage() {
      const detail = {};
      if (this.nextPageToken) {
        detail.nextPageToken = this.nextPageToken;
      }
      const e = new CustomEvent('rest-api-index-list', {
        detail: detail,
        bubbles: true,
        cancelable: true,
        composed: true
      });
      this.dispatchEvent(e);
      if (!e.defaultPrevented) {
        this._setQuerying(false);
        console.warn('REST API model detached from the dom.');
        return;
      }
      return e.detail.result
      .then((result) => {
        this._setQuerying(false);
        this.nextPageToken = result.nextPageToken;
        return result.items;
      })
      .then((items) => {
        if (!items || !items.length) {
          return;
        }
        if (!this.items) {
          items.sort(this._sortData);
          this.set('items', items);
        } else {
          const concat = this.items.concat(items);
          concat.sort(this._sortData);
          this.set('items', concat);
          this.shadowRoot.querySelector('#list').render();
        }
        setTimeout(() => this._loadPage(), 50);
      })
      .catch((e) => {
        this._setQuerying(false);
        console.error('Query menu items', e);
      });
    }
    /**
     * Sorts projects list by `order` and the `title` properties.
     */
    _sortData(a, b) {
      if (a.order < b.order) {
        return -1;
      }
      if (a.order > b.order) {
        return 1;
      }
      return a.title.localeCompare(b.title);
    }
    // Computes value for the `dataUnavailable` property.
    _computeDataUnavailable(hasItems, querying) {
      return !hasItems && !querying;
    }
    // Handler for the `tap` event on the item.
    _openAPI(e) {
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
      const id = e.model.get('item._id');
      this.dispatchEvent(new CustomEvent('navigate', {
        bubbles: true,
        composed: true,
        detail: {
          base: 'api-console',
          id: id
        }
      }));
    }
    // Handler for the `selected-rest-api-changed` event
    _selecteApiHandler(e) {
      const id = e.detail.value;
      if (id && id !== this.selectedApi) {
        this.set('selectedApi', id);
      } else {
        this.set('selectedApi', '');
      }
    }
    // Handler for the list reorder event. Updates items order in the datastore.
    _onReorder() {
      const items = this.items;
      const update = [];
      items.forEach((item, index) => {
        if (item.order !== index) {
          item.order = index;
          update.push(item);
        }
      });
      this._updateBulk(update)
      .then(() => {
        this.shadowRoot.querySelector('#list').render();
      })
      .catch((cause) => {
        this.$.reorderError.opened = true;
        console.error(cause);
      });
    }
    // Updates requests in bulk opeartion.
    _updateBulk(items) {
      const e = new CustomEvent('rest-api-index-updated-batch', {
        detail: {
          docs: items
        },
        bubbles: true,
        cancelable: true,
        composed: true
      });
      this.dispatchEvent(e);
      return e.detail.result;
    }
    // Index item has been changed in the app somewhere..
    _indexUpdated(e) {
      if (!this.items) {
        return;
      }
      const item = e.detail.doc;
      if (!this.items) {
        this.set('items', [item]);
        return;
      }
      const index = this.items.findIndex(obj => obj._id === item._id);
      if (index === -1) {
        this.push('items', item);
        this.items.sort(this._sortData);
        this.shadowRoot.querySelector('#list').render();
      } else {
        this.set(['item', index], item);
      }
    }
    // Handler for the deleted event
    _indexDeleted(e) {
      const items = this.items;
      if (!items || !items.length) {
        return;
      }
      const id = e.detail.id;
      const index = items.findIndex((item) => item._id === id);
      if (index === -1) {
        return;
      }
      this.splice('items', index, 1);
    }
  }
  window.customElements.define(RestApiMenu.is, RestApiMenu);
  </script>
</dom-module>
